curve(dbeta(x,a,b),
from=0, to=1, xlab="proportion water", ylab="",
col="black", ylim=c(0,2.75), lwd=2, xaxt="n", yaxt="n"
)
axis(1, at=c(0,0.5,1), labels=c(0,0.5,1))
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =",i))
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep("darkgray", length(l)))
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep(col1,i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep(col1,i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep(col1,i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep(col1,i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep(col1,i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
d <- c(1,0,1,1,1,0,1,0,1)
l <- ifelse(d==1, "W", "L")
a = 1
b = 1
i = 0
curve(dbeta(x,a,b),
from=0, to=1, xlab="proportion water", ylab="",
col="black", ylim=c(0,2.75), lwd=2, xaxt="n", yaxt="n"
)
axis(1, at=c(0,0.5,1), labels=c(0,0.5,1))
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =",i))
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep("darkgray", length(l)))
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep(col1,i), rep( "darkgray", length(l)-i)))
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep("black",i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep("black",i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
i = i + 1
a.prior = a
b.prior = b
a = a + d[i]
b = b + 1 - d[i]
# plot prior
curve(dbeta(x,a.prior,b.prior),
from=0, to=1,
xlab="probability of water", ylab="",
col="red", lwd=2, lty=2, ylim=c(0,2.75), xaxt="n", yaxt="n"
)
mtext(paste(l),
at=seq(from=0,to=1,length.out=length(l)),
col=c(rep("black",i), rep( "darkgray", length(l)-i)))
axis(1, at=c(0,0.5,1) , labels=c(0,0.5,1) )
title(ylab="probability", mgp=c(1,1,0))
text(0.15, 2.5, paste("n =", i))
# plot posterior
curve(dbeta(x,a,b),
from=0, to=1,
lwd=2,
add=TRUE
)
islandNumber = 1:10
populations = c(2,3,3,5,6,10,10,1,2,3)
plot(islandNumber, populations, type="h")
N=10000
locations = numeric(N)
locations[1] = sample(1:10,1) # random starting place
for (i in 2:N){
# take random walk either left or right
proposal = locations[i-1] + sample(c(-1,1), 1)
# make chain of islands circular
if (proposal==11){proposal=1}
if (proposal==0){proposal=10}
# compute acceptance ratio (ratio of pop densities)
current = pop[locations[i-1]]
proposed = pop[proposal]
acceptRatio = min(1, proposed/current)
# move or stay according to acceptance ratio
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
locations[i]=locations[i-1]
}
else{
locations[i]=proposal
}
}
for (i in 2:N){
# take random walk either left or right
proposal = locations[i-1] + sample(c(-1,1), 1)
# make chain of islands circular
if (proposal==11){proposal=1}
if (proposal==0){proposal=10}
# compute acceptance ratio (ratio of pop densities)
current = populations[locations[i-1]]
proposed = populations[proposal]
acceptRatio = min(1, proposed/current)
# move or stay according to acceptance ratio
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
locations[i]=locations[i-1]
}
else{
locations[i]=proposal
}
}
plot(locations[1:100])
hist(locations)
predictions = rbinom(1e5, size=9, prob=0.7)
plot(table(predictions), xlim=c(0,9))
par(mfrow=c(1,5))
Ps = c(0.1,0.3,0.5,0.7,0.9)
for (i in 1:5){
predictions = rbinom(1e5, size=9, prob=Ps[i])
plot(table(predictions), xlim=c(0,9), ylab="", main=paste("p=",Ps[i]))
}
par(mfrow=c(1,1))
predictions = rbinom(1e5, size=9, prob=samples)
plot(table(predictions), xlim=c(0,9))
p_grid = seq(from=0, to=1, length.out=1000)
prior = rep(1, 1000)
likelihood = dbinom(x=6, size=9, prob=p_grid)
posterior = likelihood * prior
posterior = posterior/sum(posterior)
samples = sample(p_grid, prob=posterior, size=10000, replace=TRUE)
plot(samples)
plot(density(samples))
plot(samples, col="blue")
plot(density(samples))
plot(density(samples), lwd=2)
predictions = rbinom(1e5, size=9, prob=0.7)
plot(table(predictions), xlim=c(0,9))
par(mfrow=c(1,5))
Ps = c(0.1,0.3,0.5,0.7,0.9)
for (i in 1:5){
predictions = rbinom(1e5, size=9, prob=Ps[i])
plot(table(predictions), xlim=c(0,9), ylab="", main=paste("p=",Ps[i]))
}
predictions = rbinom(1e5, size=9, prob=samples)
plot(table(predictions), xlim=c(0,9))
par(mfrow=c(1,1))
predictions = rbinom(1e5, size=9, prob=samples)
plot(table(predictions), xlim=c(0,9))
islandNumber = 1:10
populations = c(2,3,3,5,6,10,10,1,2,3)
plot(islandNumber, populations, type="h")
N=10000
locations = numeric(N)
locations[1] = sample(1:10,1) # random starting place
for (i in 2:N){
# take random walk either left or right
proposal = locations[i-1] + sample(c(-1,1), 1)
# make chain of islands circular
if (proposal==11){proposal=1}
if (proposal==0){proposal=10}
# compute acceptance ratio (ratio of pop densities)
current = populations[locations[i-1]]
proposed = populations[proposal]
acceptRatio = min(1, proposed/current)
# move or stay according to acceptance ratio
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
locations[i]=locations[i-1]
}
else{
locations[i]=proposal
}
}
plot(table(locations))
table(locations)
table(locations/N)
table(locations)/N
populations/sum(populations)
plot(islandNumber, populations, type="h")
plot(locations[1:100])
plot(table(locations))
N=10000
samples = numeric(N)
likelihood = function(data, par){
return(dbinom(x=data, prob=par, size=9))
}
prior = function(data, par){
return(dunif(x=data, min=0, max=1))
}
posterior = function(data, par){
return(likelihood(data, par)*prior(data, par))
}
N=10000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
??indicator
N=10000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
for (i in 2:N){
proposal = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
posterior(data=6, par=0.5)
prior = function(data, par){
return(dunif(x=par, min=0, max=1))
}
posterior = function(data, par){
return(likelihood(data, par)*prior(data, par))
}
prior(data=6, par=0.5)
prior(data=6, par=0.7)
likelihood(data=6, par=0.5)
likelihood(data=6, par=0.7)
posterior(data=6, par=0.5)
N=10000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
for (i in 2:N){
proposal = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
plot(samples)
plot(samples, type="l")
plot(samples, type="l")
plot(density(samples), lwd=2)
plot(density(samples[2000:10000]), lwd=2)
plot(density(samples), lwd=2)
N=100000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
for (i in 2:N){
proposal = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
plot(samples, type="l")
plot(density(samples), lwd=2)
N=10000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
for (i in 2:N){
proposal = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
plot(samples, type="l")
plot(density(samples), lwd=2)
prior = function(data, par){
return(dunif(x=par, min=0.5, max=1))
}
posterior = function(data, par){
return(likelihood(data, par)*prior(data, par))
}
N=10000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
for (i in 2:N){
proposal = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
plot(samples, type="l")
plot(density(samples), lwd=2)
plot(density(samples), lwd=2, xlim=c(0,1))
return(1)
return 1
0
proposal = function(){
prop = rnorm(1, mean=samples[i-1], sd=0.1)
if (prop >0){
return(min(prop,1))
}
else {
return(max(prop,0))
}
}
proposal
proposal()
proposal()
proposal()
N=10000
samples = numeric(N)
samples[1] = runif(1, min=0, max=1)
for (i in 2:N){
proposal() # = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
for (i in 2:N){
proposal=proposal() # = runif(1, min=0, max=1)
# acceptance ratio
current = posterior(data=6, par=samples[i-1])
proposed = posterior(data=6, par=proposal)
acceptRatio = min(1, proposed/current)
# move or stay
makeStep = rbinom(1, size=1, prob=acceptRatio)
if (makeStep==0){
samples[i]=samples[i-1]
}
else {
samples[i]=proposal
}
}
??censor
