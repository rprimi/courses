<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Week 5 lecture notes - PSYC 5316</title>
<!-- 2017-09-25 Mon 10:50 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Week 5 lecture notes - PSYC 5316</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
In this lecture, we will learn how to work with large data sets.  Data sets are commonly represented as <i>data frames</i>.  To begin, we'll use the <code>read_csv</code> function to load a data frame.  First, load the <code>tidyverse</code> package, and then execute the <code>read_csv</code> commmand.
</p>

<pre class="example">
library(tidyverse)
rawdata = read_csv("https://git.io/vdkRH")
</pre>

<p>
(Note: if you haven't already installed <code>tidyverse</code>, you can do so by executing <code>install.packages("tidyverse")</code> at the console.
</p>

<p>
This data set comes from Experiment 2 of Faulkenberry, Cruise, Lavro, and Shaki (2016).  In this experiment, we presented people with pairs of single-digit numbers written in two different font sizes. We asked them to use a computer mouse to click on the <i>physically larger</i> of the pair.  This resulted in experimental conditions: <i>congruent</i> trials, where the physically larger number was also numerically larger, and <i>incongruent</i> trials, where the physically larger number was numerically smaller.  We measured RT in milliseconds.
</p>

<p>
The data file is structured with the following columns:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">column</th>
<th scope="col" class="left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">subject</td>
<td class="left">number representing subject identifier</td>
</tr>

<tr>
<td class="left">condition</td>
<td class="left">size-congruity condition: either "congruent" or "incongruent"</td>
</tr>

<tr>
<td class="left">distance</td>
<td class="left">numerical distance between presented numbers (1,2,3, or 4)</td>
</tr>

<tr>
<td class="left">error</td>
<td class="left">indicates whether error was made on trial: 0 = no error, 1=error</td>
</tr>

<tr>
<td class="left">RT</td>
<td class="left">response time in milliseconds</td>
</tr>

<tr>
<td class="left">side</td>
<td class="left">side of display on which the physically larger number was presented (either left or right)</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">What are data frames?</h2>
<div class="outline-text-2" id="text-2">
<p>
Data frames are the de facto data structure for most tabular data, and what we use for statistics and plotting.
</p>

<p>
A data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because the column are vectors, they all contain the same type of data (e.g., characters, integers, factors).
</p>

<p>
We can see this when inspecting the structure of our data frame with the function <code>glimpse</code>:
</p>

<pre class="example">
glimpse(rawdata)
</pre>

<p>
In addition to <code>glimpse</code>, there are some other functions that will help you to get a sense of the content/structure of your data:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Size</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>dim</code></td>
<td class="left">returns a vector with the number of rows in the first element, and the number of columns as the second element</td>
</tr>

<tr>
<td class="left"><code>nrow</code></td>
<td class="left">returns the number of rows</td>
</tr>

<tr>
<td class="left"><code>ncol</code></td>
<td class="left">returns the number of columns</td>
</tr>

<tr>
<td class="left">Content</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left"><code>head</code></td>
<td class="left">shows the first 6 rows</td>
</tr>

<tr>
<td class="left"><code>tail</code></td>
<td class="left">shows the last 6 rows</td>
</tr>

<tr>
<td class="left"><code>names</code></td>
<td class="left">returns the column names</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Data manipulation using <code>tidyr</code> and <code>dplyr</code></h2>
<div class="outline-text-2" id="text-3">
<p>
<code>dplyr</code> is a package for making tabular data manipulation easier. It pairs nicely with <code>tidyr</code> which enables you to swiftly convert between different data formats for plotting and analysis.
</p>

<p>
The package <code>dplyr</code> provides easy tools for the most common data manipulation tasks. It is built to work directly with data frames, with many common tasks optimized by being written in a compiled language (C++). An additional feature is the ability to work directly with data stored in an external database. The benefits of doing this are that the data can be managed natively in a relational database, queries can be conducted on that database, and only the results of the query are returned.
</p>

<p>
This addresses a common problem with R in that all operations are conducted in-memory and thus the amount of data you can work with is limited by available memory. The database connections essentially remove that limitation in that you can have a database of many 100s GB, conduct queries on it directly, and pull back into R only what you need for analysis.
</p>

<p>
The package <code>tidyr</code> addresses the common problem of wanting to reshape your data for plotting and use by different R functions. Sometimes we want data sets where we have one row per measurement. Sometimes we want a data frame where each measurement type has its own column, and rows are instead more aggregated groups. Moving back and forth between these formats is nontrivial, and <code>tidyr</code> gives you tools for this and more sophisticated data manipulation.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Selecting columns and filtering rows</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We're going to learn some of the most common <code>dplyr</code> functions (also called <b>verbs</b>): <code>select()</code>, <code>filter()</code>, <code>mutate()</code>, <code>group_by()</code>, and <code>summarize()</code>. 
</p>

<p>
To choose <i>columns</i> of a data frame, use <code>select()</code>. The first argument to this function is the data frame (<code>rawdata</code>), and the subsequent arguments are the columns to keep.
</p>

<pre class="example">
select(rawdata, condition, error, RT)
</pre>

<p>
To choose <i>rows</i> based on specific criteria, use <code>filter()</code>
</p>

<pre class="example">
filter(rawdata, error==0)
</pre>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Pipes</h3>
<div class="outline-text-3" id="text-3-2">
<p>
But what if you wanted to select and filter at the same time?  There are many ways to do this, but the quickest and easiest is to use <b>pipes</b>.
</p>

<p>
Pipes are a fairly recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like <code>%&gt;%</code> and are made available via the <code>magrittr</code> package, installed automatically with <code>dplyr</code>. 
</p>

<pre class="example">
rawdata %&gt;%
  filter(error==0) %&gt;%
  select(subject, condition, RT)
</pre>

<p>
In the above code chunk, we use the pipe to send the <code>rawdata</code> dataset first through <code>filter()</code> to keep only the rows where <code>error=0</code>.  Then, we pass that output through the <code>select()</code> function to keep only the columns <code>subject</code>, <code>condition</code>, and <code>RT</code>.
</p>

<p>
Note that using the pipe operator <code>%&gt;%</code> removes the need to specify the dataset as the first argument to the <code>filter()</code> or <code>select()</code> functions.
</p>

<p>
If we wanted to create a new object of this smaller version of the data, we could do so by using the assignment operator <code>&lt;-</code>:
</p>

<pre class="example">
data &lt;- rawdata %&gt;%
  filter(error==0)
</pre>

<p>
If you look in the "Environment" tab, you'll notice that the row dimension has reduced to 15,686.  This tells us that there were 44 errors across all participants and trials.
</p>
</div>
</div>


<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Mutate</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Frequently you will want to create new columns based on the values in existing columns.  For example, we might want to express response time (RT) in seconds rather than milliseconds.  For this, we'll use <code>mutate()</code>:
</p>

<pre class="example">
data %&gt;%
  mutate(RT_sec = RT/1000)
</pre>

<p>
Another good use of <code>mutate()</code> is for recoding a variable.  For example, the column <code>distance</code> currently has 4 values: 1, 2, 3, and 4.  Suppose we want to recode this variable to have two values: close (distance=1 or 2) and far (distance=3 or 4).  We can use <code>mutate()</code> along with <code>ifelse()</code> to do this:
</p>

<pre class="example">
data %&gt;%
  mutate(dist = ifelse(distance==1 | distance==2, "close", "far"))
</pre>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Summarize</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Many data analysis tasks can be approached using the <i>split-apply-combine</i> paradigm: split the data into groups, apply some analysis to each group, then combine the results.  <code>dplyr</code> makes this very easy using the functions <code>group_by()</code> and <code>summarize()</code>.
</p>

<p>
The following code chunk illustrates this:
</p>

<pre class="example">
data %&gt;%
  group_by(condition) %&gt;%
  summarize(meanRT = mean(RT))
</pre>

<p>
<code>group_by()</code> takes as its argument the column name(s) that contain the categorical variables for which you want to calculate a summary statistic (e.g., mean).  In this example, we are interested in the mean RT by condition.  You'll notice that incongruent trials take slightly longer than congruent trials.  This is the <i>size-congruity</i> effect, first demonstrated by Henik and Tzelgov in 1982.
</p>

<p>
Note that you can also group by multiple columns.  Suppose we were interested in the mean RT by condition AND distance.
</p>

<pre class="example">
data %&gt;%
  group_by(condition, distance) %&gt;%
  summarize(meanRT = mean(RT))
</pre>

<p>
Also, we can compute multiple statistics:
</p>

<pre class="example">
data %&gt;%
  group_by(condition, distance) %&gt;%
  summarize(meanRT=mean(RT), sd=sd(RT))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Visualizing data with <code>ggplot2</code></h2>
<div class="outline-text-2" id="text-4">
<p>
<code>ggplot2</code> is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change
or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.
</p>

<p>
<code>ggplot</code> likes data in the 'long' format: i.e., a column for every variable, and a row for every observation. Well structured data will save you lots of time when making figures with <code>ggplot</code>.
</p>

<p>
<code>ggplot</code> graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.
</p>

<p>
To build a <code>ggplot</code>, we need to:
</p>

<ul class="org-ul">
<li>pipe our data to the <code>ggplot()</code> function
</li>
<li>define <i>aesthetics</i> (<code>aes</code>) by selecting the variables to be plotted and the variables to define the presentation.
</li>
<li>add <code>geoms</code>, which are graphical representations in the plot (points, lines,bars).
</li>
</ul>

<p>
We will now construct some examples of what is possible using <code>ggplot</code>:
</p>

<pre class="example">
data %&gt;%
  ggplot(aes(x=condition, y=RT)) +
  geom_boxplot()
</pre>

<p>
This gives us a vertically oriented boxplot:
</p>


<div class="figure">
<p><img src="figures/week5/boxplot.png" alt="boxplot.png" />
</p>
</div>

<p>
We can switch the orientation to horizontal by adding the <code>coord_flip()</code> function.
</p>

<pre class="example">
data %&gt;%
  ggplot(aes(x=condition, y=RT)) +
  geom_boxplot() +
  coord_flip()
</pre>


<div class="figure">
<p><img src="figures/week5/boxplotHorizontal.png" alt="boxplotHorizontal.png" />
</p>
</div>

<p>
Boxplots are fine, but they hide the <i>shape</i> of the distribution.  Let's try plotting some histograms.
</p>

<pre class="example">
data %&gt;%
  ggplot(aes(x=RT, group=condition)) +
  geom_histogram(aes(fill=condition))
</pre>


<div class="figure">
<p><img src="figures/week5/histogram.png" alt="histogram.png" />
</p>
</div>

<p>
In this plot, the histograms are overlaid on the same plot.  We can split them up using <i>faceting</i>:
</p>

<pre class="example">
data %&gt;%
  ggplot(aes(x=RT)) +
  geom_histogram() +
  facet_grid(condition~.)
</pre>


<div class="figure">
<p><img src="figures/week5/faceted.png" alt="faceted.png" />
</p>
</div>

<p>
Note: density plots can be made in the same way..just use <code>geom_density</code> instead of <code>geom_histogram</code>
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">plotting summaries</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Usually, we are interested in the differences between condition means.  We will demonstrate this using two types of plots: a bar plot, and a line plot.
</p>

<p>
First, lets look at a bar plot that demonstrates the difference in condition means between incongruent and congruent trials.  Notice how we are using the "split-apply-combine" paradigm along with <code>ggplot</code> here:
</p>

<pre class="example">
data %&gt;%
  group_by(condition) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  ggplot(aes(x=condition,y=meanRT)) +
  geom_bar(stat="identity", width=0.5)
</pre>


<div class="figure">
<p><img src="figures/week5/barplot1.png" alt="barplot1.png" />
</p>
</div>

<p>
Similarly, a small change can produce a line plot instead:
</p>

<pre class="example">
data %&gt;%
  group_by(condition) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  ggplot(aes(x=condition, y=meanRT, group=1)) +
  geom_line() +
  geom_point()
</pre>


<div class="figure">
<p><img src="figures/week5/lineplot1.png" alt="lineplot1.png" />
</p>
</div>

<p>
Notice that this is a terrible plot, though, because the y-axis is truncated.  Adding a line with <code>ylim(0,1500)</code> will make the plot better (try it!)
</p>

<p>
What if we were interested in the differences in mean RT by distance?  We can easily edit our code above to get bar plots and line plots for distance instead of condition:
</p>

<p>
Bar plot:
</p>

<pre class="example">
data %&gt;%
  group_by(distance) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  ggplot(aes(x=distance, y=meanRT)) +
  geom_bar(stat="identity", width=0.5)
</pre>


<div class="figure">
<p><img src="figures/week5/barplot2.png" alt="barplot2.png" />
</p>
</div>

<p>
Line plot:
</p>

<pre class="example">
data %&gt;%
  group_by(distance) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  ggplot(aes(x=distance, y=meanRT, group=1)) +
  geom_line() +
  geom_point() +
  ylim(0,1500)
</pre>


<div class="figure">
<p><img src="figures/week5/lineplot2.png" alt="lineplot2.png" />
</p>
</div>

<p>
Both plots indicate that numerical distance doesn't seem to have much effect on RTs.  
</p>

<p>
However, a more interesting plot might reveal something different!  Lets see what happens when we plot BOTH condition and distance on the same plot:
</p>

<p>
Bar plot:
</p>

<pre class="example">
data %&gt;%
  group_by(condition, distance) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  ggplot(aes(x=distance, y=meanRT, fill=condition)) +
  geom_bar(stat="identity", position=position_dodge(), color="black")
</pre>


<div class="figure">
<p><img src="figures/week5/barplot3.png" alt="barplot3.png" />
</p>
</div>

<p>
Line plot:
</p>

<pre class="example">
data %&gt;%
  group_by(condition, distance) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  ggplot(aes(x=distance, y=meanRT, linetype=condition)) +
  geom_line() +
  geom_point() +
  ylim(0,1500)
</pre>


<div class="figure">
<p><img src="figures/week5/lineplot3.png" alt="lineplot3.png" />
</p>
</div>

<p>
It appears that the effect of condition may be increasing as numerical distance increases.  If so, this is called an <i>interaction</i> effect.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Performing statistical tests</h2>
<div class="outline-text-2" id="text-5">
<p>
In this section, we will back up our plots by performing statistical tests.  The tests will perform are the paired samples t-test and a couple of ANOVAs (analysis of variance).
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">t-test: comparing mean RTs by condition</h3>
<div class="outline-text-3" id="text-5-1">
<p>
For our first case study, lets look at the effect of condition and see if we find a significant size-congruity effect.  That is, are response times on incongruent trials significantly longer than congruent trials?
</p>

<p>
When participants complete multiple experimental trials, the first step is to collapse all trials into single summary stats (usually the mean).  We can use the "split-apply-combine" paradigm to see this.
</p>

<p>
First, let's see how many participants we had:
</p>

<pre class="example">
length(unique(data$subject))
</pre>

<p>
Now, split-apply-combine will give us a mean RT for each condition and subject.  That is, we should get 41x2=82 different mean RTs.  We'll add the <code>print(n=82)</code> to the end in order to see all 82 rows.
</p>

<pre class="example">
data %&gt;%
  group_by(subject, condition) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  print(n=82)
</pre>

<p>
Since "condition" is a within-subjects manipulation (each participant completed both experimental conditions), we'll need to use a paired-samples t-test.  The <code>t.test</code> function in R requires two vectors as input.  We'll use our <code>tidyverse</code> verbs to construct both of these vectors; one for congruent trials, and one for incongruent trials:
</p>

<pre class="example">
congruent &lt;- data %&gt;%
  group_by(subject, condition) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  filter(condition=="congruent") %&gt;%
  select(subject,meanRT)

incongruent &lt;- data %&gt;%
  group_by(subject, condition) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  filter(condition=="incongruent") %&gt;%
  select(subject,meanRT)
</pre>

<p>
Now, to perform the t-test, we simply type the following:
</p>

<pre class="example">
t.test(incongruent$meanRT, congruent$meanRT, paired=TRUE)
</pre>

<p>
From the output, we can see there is indeed a significant increase in RTs for incongruent trials, \(t(40)=7.48\), \(p<0.001\).  Also, we get a 95% confidence interval for the increase as (36.9, 64.3).
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">one-way ANOVA: comparing mean RTs by numerical distance</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Recall when we plotted mean RT against distance, there did not appear to be much of a difference.  Lets test this with a one-way ANOVA.
</p>

<p>
The ANOVA procedures are a bit different than the t-test.  First, we collapse all the trials to a single mean RT for each subject x distance combination.  Note: we should expect 41x4=164 different mean RTs.
</p>

<pre class="example">
dataByDistance &lt;- data %&gt;%
  group_by(subject, distance) %&gt;%
  summarize(meanRT=mean(RT)) %&gt;%
  mutate(distance=as.factor(distance))
</pre>

<p>
Note: the last <code>mutate</code> command is necessary to make the ANOVA work correctly.  All independent variables in an ANOVA model <b>must</b> be "factors".  This command forces R to interpret the numbers 1,2,3,4 as levels of a single categorical factor instead of values of some continuous variable.
</p>

<p>
Next, we define the ANOVA model:
</p>

<pre class="example">
distance.aov = aov(meanRT~distance + 
                   Error(as.factor(subject)/distance), 
                   data=dataByDistance
                   )
</pre>

<p>
Note again the <code>as.factor()</code> command; this time, it is used to force the <code>subject</code> variable to be read as categorical.  
</p>

<p>
Finally, we can see the usual ANOVA table by using the <code>summary()</code> function:
</p>

<pre class="example">
summary(distance.aov)
</pre>

<p>
The output confirms our suspicion.  There was no effect of distance on mean RTs, \(F(3,120)=0.45\), \(p=0.72\).
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Factorial ANOVA: mean RT by condition and distance</h3>
<div class="outline-text-3" id="text-5-3">
<p>
In one of our figures above, we saw that the difference in RTs between congruent and incongruent trials seemed to <i>increase</i> as numerical distance increased.  If so, this would be an <i>interaction</i> between condition and distance.  To test this, we use a factorial anova.
</p>

<pre class="example">
dataFactorial &lt;- data %&gt;%
  group_by(subject, condition, distance) %&gt;%
  summarize(meanRT = mean(RT)) %&gt;%
  mutate(distance=as.factor(distance))

factorial.aov = aov(meanRT ~ condition*distance + 
                    Error(as.factor(subject)/(condition*distance)), 
                    data=dataFactorial
                    )
summary(factorial.aov)
</pre>

<p>
As we can see, the overall picture we've suspected is confirmed:
</p>

<ul class="org-ul">
<li>there was a significant main effect of condition.  Mean RTs on incongruent trials were significantly longer than congruent trials, \(F(1,40)=55.91\), \(p<0.001\).
</li>
<li>there was no effect of distance, \(F(3,120)=0.46\), \(p=0.71\).
</li>
<li>however, there was a significant interaction between condition and distance, \(F(3,120)=7.86\), \(p<0.001\).  
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: September 25, 2017</p>
<p class="date">Created: 2017-09-25 Mon 10:50</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
